"use client"

import { useMemo, useState, useEffect, useRef } from "react"
import {
  Lightbulb,
  ChevronDown,
  ChevronRight,
  Copy,
  Check,
  Sparkles,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Badge } from "@/components/ui/badge"
import { cn } from "@/lib/utils"
import type { Engagement, Target, Rule } from "@/lib/types"
import {
  evaluateAllRules,
  groupSuggestionsByService,
  type EvaluatedSuggestion,
  type GroupedSuggestions,
} from "@/lib/rule-evaluator"

interface SuggestionsPanelProps {
  targets: Target[]
  activeEngagement: Engagement
  rules: Rule[]
  selectedTarget?: Target | null
}

const confidenceColors: Record<string, { bg: string; text: string; border: string }> = {
  high: {
    bg: "bg-success/20",
    text: "text-success",
    border: "border-success/30",
  },
  medium: {
    bg: "bg-warning/20",
    text: "text-warning",
    border: "border-warning/30",
  },
  low: {
    bg: "bg-muted",
    text: "text-muted-foreground",
    border: "border-muted",
  },
}

function SuggestionsPanelHeader({ count }: { count: number }) {
  return (
    <div className="flex h-10 items-center justify-between border-b border-border px-3">
      <div className="flex items-center gap-2">
        <Lightbulb className="h-4 w-4 text-muted-foreground" />
        <span className="text-sm font-medium">Suggestions</span>
        {count > 0 && (
          <Badge variant="secondary" className="h-5 px-1.5 text-[10px]">
            {count}
          </Badge>
        )}
      </div>
    </div>
  )
}

function SuggestionItem({
  suggestion,
  onCopyCommand,
  selectedTarget,
  targets,
}: {
  suggestion: EvaluatedSuggestion
  onCopyCommand: (command: string) => void
  selectedTarget?: Target | null
  targets: Target[]
}) {
  const [copiedIndex, setCopiedIndex] = useState<number | null>(null)
  const confidenceStyle = confidenceColors[suggestion.confidence]

  // Get target IP for replacing <target> placeholder
  const targetIp = selectedTarget?.ip || targets[0]?.ip || "<target>"

  const handleCopy = (command: string, index: number) => {
    onCopyCommand(command)
    setCopiedIndex(index)
    setTimeout(() => setCopiedIndex(null), 2000)
  }

  return (
    <div
      className={cn(
        "mb-2 rounded-md border p-3 transition-colors",
        confidenceStyle.border,
        "hover:bg-secondary/50"
      )}
    >
      <div className="mb-2 flex items-start justify-between gap-2">
        <div className="flex-1">
          <div className="mb-1 flex items-center gap-2">
            <h4 className="text-sm font-semibold">{suggestion.title}</h4>
            <Badge
              variant="outline"
              className={cn("h-4 px-1 text-[9px]", confidenceStyle.text, confidenceStyle.border)}
            >
              {suggestion.confidence}
            </Badge>
            {suggestion.owaspTag && (
              <Badge variant="secondary" className="h-4 px-1 text-[9px]">
                {suggestion.owaspTag}
              </Badge>
            )}
          </div>
          {suggestion.description && (
            <p className="text-xs text-muted-foreground">{suggestion.description}</p>
          )}
        </div>
      </div>

      {suggestion.commands && suggestion.commands.length > 0 && (
        <div className="mt-2 space-y-1">
          {suggestion.commands.map((command, index) => {
            // Replace <target> placeholder with actual IP address
            const commandWithTarget = command.replace(/<target>/g, targetIp)
            return (
              <div
                key={index}
                className="group flex items-center gap-2 rounded border border-border bg-muted/30 p-2 font-mono text-xs"
              >
                <code className="flex-1 break-all text-[11px]">{commandWithTarget}</code>
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-6 w-6 shrink-0 p-0 opacity-0 transition-opacity group-hover:opacity-100"
                  onClick={() => handleCopy(command, index)}
                  title="Copy command"
                >
                  {copiedIndex === index ? (
                    <Check className="h-3 w-3 text-success" />
                  ) : (
                    <Copy className="h-3 w-3" />
                  )}
                </Button>
              </div>
            )
          })}
        </div>
      )}
    </div>
  )
}

function SuggestionGroup({
  service,
  suggestions,
  onCopyCommand,
  selectedTarget,
  targets,
}: {
  service: string
  suggestions: EvaluatedSuggestion[]
  onCopyCommand: (command: string) => void
  selectedTarget?: Target | null
  targets: Target[]
}) {
  const [expanded, setExpanded] = useState(true)

  return (
    <div className="mb-3">
      <button
        type="button"
        onClick={() => setExpanded(!expanded)}
        className="flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-left text-xs font-medium text-muted-foreground transition-colors hover:bg-secondary/50"
      >
        {expanded ? (
          <ChevronDown className="h-3.5 w-3.5 shrink-0" />
        ) : (
          <ChevronRight className="h-3.5 w-3.5 shrink-0" />
        )}
        <span className="flex-1 capitalize">{service}</span>
        <Badge variant="secondary" className="h-4 px-1.5 text-[9px]">
          {suggestions.length}
        </Badge>
      </button>
      {expanded && (
        <div className="ml-4 mt-1 space-y-2">
          {suggestions.map((suggestion, index) => (
            <SuggestionItem 
              key={`${suggestion.ruleId}-${index}`} 
              suggestion={suggestion} 
              onCopyCommand={onCopyCommand}
              selectedTarget={selectedTarget}
              targets={targets}
            />
          ))}
        </div>
      )}
    </div>
  )
}

function EmptyState() {
  return (
    <div className="flex flex-col items-center justify-center p-8 text-center">
      <Sparkles className="mb-3 h-12 w-12 text-muted-foreground/50" />
      <p className="mb-1 text-sm font-medium text-foreground">No suggestions available</p>
      <p className="text-xs text-muted-foreground">
        Add targets and ports to get started, or check that rules are enabled for the current phase.
      </p>
    </div>
  )
}

export function SuggestionsPanel({
  targets,
  activeEngagement,
  rules,
  selectedTarget,
}: SuggestionsPanelProps) {
  const [suggestions, setSuggestions] = useState<EvaluatedSuggestion[]>([])
  const [loading, setLoading] = useState(false)
  const abortControllerRef = useRef<AbortController | null>(null)
  const lastEvaluationRef = useRef<string>("")
  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const isEvaluatingRef = useRef(false)

  // Store previous values in refs to compare actual changes
  const prevRulesIdsRef = useRef<string>("")
  const prevTargetsIdsRef = useRef<string>("")
  const prevEngagementRef = useRef<{ id: string; phase: string } | null>(null)
  const prevSelectedTargetIdRef = useRef<string | null>(null)

  // Create evaluation key only when actual data changes
  const getEvaluationKey = () => {
    if (!activeEngagement || rules.length === 0) return ""
    const rulesIds = rules.map(r => r.id).sort().join(",")
    const targetsIds = targets.map(t => t.id).sort().join(",")
    return `${activeEngagement.id}:${activeEngagement.phase}:${rules.length}:${rulesIds}:${targets.length}:${targetsIds}:${selectedTarget?.id || "null"}`
  }

  // Check if data actually changed
  const hasDataChanged = () => {
    const rulesIds = rules.map(r => r.id).sort().join(",")
    const targetsIds = targets.map(t => t.id).sort().join(",")
    const engagementChanged = 
      !prevEngagementRef.current ||
      prevEngagementRef.current.id !== activeEngagement?.id ||
      prevEngagementRef.current.phase !== activeEngagement?.phase
    const rulesChanged = prevRulesIdsRef.current !== rulesIds
    const targetsChanged = prevTargetsIdsRef.current !== targetsIds
    const selectedTargetChanged = prevSelectedTargetIdRef.current !== (selectedTarget?.id || null)

    if (engagementChanged || rulesChanged || targetsChanged || selectedTargetChanged) {
      prevRulesIdsRef.current = rulesIds
      prevTargetsIdsRef.current = targetsIds
      prevEngagementRef.current = activeEngagement ? { id: activeEngagement.id, phase: activeEngagement.phase } : null
      prevSelectedTargetIdRef.current = selectedTarget?.id || null
      return true
    }
    return false
  }

  // Evaluate rules asynchronously with debouncing
  useEffect(() => {
    // Clear any pending debounce
    if (debounceTimeoutRef.current) {
      clearTimeout(debounceTimeoutRef.current)
    }

    // Cancel previous request if still pending
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }

    if (!activeEngagement || rules.length === 0) {
      setSuggestions([])
      lastEvaluationRef.current = ""
      prevRulesIdsRef.current = ""
      prevTargetsIdsRef.current = ""
      prevEngagementRef.current = null
      prevSelectedTargetIdRef.current = null
      return
    }

    // Check if data actually changed
    if (!hasDataChanged()) {
      return
    }

    const currentKey = getEvaluationKey()
    
    // Skip if evaluation key hasn't changed (double-check)
    if (currentKey === lastEvaluationRef.current) {
      return
    }

    // Debounce the evaluation to prevent rapid-fire requests
    debounceTimeoutRef.current = setTimeout(() => {
      // Double-check key hasn't changed during debounce
      const finalKey = getEvaluationKey()
      if (finalKey === lastEvaluationRef.current) {
        return
      }
      lastEvaluationRef.current = finalKey

      // Prevent concurrent evaluations
      if (isEvaluatingRef.current) {
        return
      }
      isEvaluatingRef.current = true

      // Create new abort controller for this request
      const abortController = new AbortController()
      abortControllerRef.current = abortController

      setLoading(true)
      
      // Add timeout to prevent hanging requests
      const timeoutId = setTimeout(() => {
        if (!abortController.signal.aborted) {
          abortController.abort()
          console.warn("Rule evaluation request timed out")
          setSuggestions([])
          setLoading(false)
          isEvaluatingRef.current = false
        }
      }, 8000) // 8 second timeout

      evaluateAllRules(rules, activeEngagement, targets, selectedTarget)
        .then((result) => {
          if (!abortController.signal.aborted) {
            setSuggestions(result)
            setLoading(false)
            clearTimeout(timeoutId)
            isEvaluatingRef.current = false
          }
        })
        .catch((error) => {
          if (!abortController.signal.aborted) {
            console.error("Failed to evaluate rules:", error)
            setSuggestions([])
            setLoading(false)
            clearTimeout(timeoutId)
            isEvaluatingRef.current = false
          }
        })
    }, 500) // 500ms debounce

    return () => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current)
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }
    // Only depend on primitive values that actually matter
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeEngagement?.id, activeEngagement?.phase, rules.length, targets.length, selectedTarget?.id])

  // Group suggestions by service
  const groupedSuggestions = useMemo(() => {
    return groupSuggestionsByService(suggestions)
  }, [suggestions])

  const totalSuggestions = useMemo(() => {
    return Object.values(groupedSuggestions).reduce((sum, group) => sum + group.length, 0)
  }, [groupedSuggestions])

  const handleCopyCommand = (command: string) => {
    // Replace <target> placeholder with selected target IP or first target IP
    const targetIp = selectedTarget?.ip || targets[0]?.ip || "<target>"
    const commandWithTarget = command.replace(/<target>/g, targetIp)
    navigator.clipboard.writeText(commandWithTarget)
  }

  const services = Object.keys(groupedSuggestions).sort()

  return (
    <div className="flex h-full w-full flex-col border-l border-border bg-card">
      <SuggestionsPanelHeader count={totalSuggestions} />
      
      <ScrollArea className="flex-1">
        <div className="p-3">
          {totalSuggestions === 0 ? (
            <EmptyState />
          ) : (
            <div>
              {services.map((service) => (
                <SuggestionGroup
                  key={service}
                  service={service}
                  suggestions={groupedSuggestions[service]}
                  onCopyCommand={handleCopyCommand}
                  selectedTarget={selectedTarget}
                  targets={targets}
                />
              ))}
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  )
}
