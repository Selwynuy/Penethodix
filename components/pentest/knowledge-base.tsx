"use client"

import { useState, useMemo, useEffect, forwardRef, useImperativeHandle, type ReactNode, useCallback } from "react"
import {
  Search,
  Plus,
  FileText,
  Copy,
  Pencil,
  Files,
  Link2,
  ChevronRight,
  ChevronDown,
  X,
  Check,
  Filter,
  Trash2,
  Edit,
  Download,
  Upload,
  Folder,
  FolderOpen,
  MoreVertical,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Badge } from "@/components/ui/badge"
import { Textarea } from "@/components/ui/textarea"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Label } from "@/components/ui/label"
import { cn } from "@/lib/utils"
import { notification } from "@/components/ui/notification"
import type { KnowledgeEntry, KnowledgeCategory, Engagement, ImportableKnowledgeEntry } from "@/lib/types"
import { useCategoriesContext } from "@/contexts/categories-context"
import { usePhasesContext } from "@/contexts/phases-context"
import { buildCategoryTree, type Category, type CategoryTreeNode } from "@/hooks/use-categories"
import type { Phase } from "@/hooks/use-phases"

interface KnowledgeBaseProps {
  entries: KnowledgeEntry[]
  onAddEntry?: (entry: Omit<KnowledgeEntry, "id" | "createdAt" | "updatedAt">) => void
  onUpdateEntry?: (id: string, entry: Partial<KnowledgeEntry>) => void
  onDeleteEntry?: (id: string) => void
}

export interface KnowledgeBaseHandle {
  openAddEntryDialog: () => void
  openAddCategoryDialog: () => void
  getSelectedCategory: () => KnowledgeCategory | null
}

// Default color palette for categories
const defaultColors = [
  "bg-blue-500/20 text-blue-400",
  "bg-purple-500/20 text-purple-400",
  "bg-red-500/20 text-red-400",
  "bg-orange-500/20 text-orange-400",
  "bg-cyan-500/20 text-cyan-400",
  "bg-green-500/20 text-green-400",
  "bg-yellow-500/20 text-yellow-400",
  "bg-pink-500/20 text-pink-400",
  "bg-indigo-500/20 text-indigo-400",
  "bg-teal-500/20 text-teal-400",
]

// Generate a color based on category name (deterministic)
function getCategoryColor(categoryName: string, categories: Category[]): string {
  const category = categories.find((c) => c.name === categoryName)
  if (category?.color) return category.color
  
  // Generate deterministic color based on name
  let hash = 0
  for (let i = 0; i < categoryName.length; i++) {
    hash = categoryName.charCodeAt(i) + ((hash << 5) - hash)
  }
  const index = Math.abs(hash) % defaultColors.length
  return defaultColors[index]
}

// Helper to get phase color
function getPhaseColor(phaseName: string, phases: Phase[]): string {
  const phase = phases.find((p) => p.name === phaseName)
  if (phase?.color) return phase.color
  
  // Generate deterministic color based on name
  let hash = 0
  for (let i = 0; i < phaseName.length; i++) {
    hash = phaseName.charCodeAt(i) + ((hash << 5) - hash)
  }
  const index = Math.abs(hash) % defaultColors.length
  return defaultColors[index]
}

// Strip sensitive fields for export (id, createdAt, updatedAt)
function stripSensitiveFields(entry: KnowledgeEntry): ImportableKnowledgeEntry {
  const { id, createdAt, updatedAt, ...exportableEntry } = entry
  return exportableEntry
}

export const KnowledgeBase = forwardRef<KnowledgeBaseHandle, KnowledgeBaseProps>(
  ({ entries, onAddEntry, onUpdateEntry, onDeleteEntry }, ref) => {
  const { categories, createCategory, updateCategory, deleteCategory } = useCategoriesContext()
  const { phases, createPhase, updatePhase, deletePhase } = usePhasesContext()
  const [selectedCategory, setSelectedCategory] = useState<KnowledgeCategory | null>(null)
  const [selectedCategoryNode, setSelectedCategoryNode] = useState<Category | null>(null) // For viewing/editing category content
  const [selectedEntry, setSelectedEntry] = useState<KnowledgeEntry | null>(null)
  const [isEditingCategory, setIsEditingCategory] = useState(false) // For editing category content
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set()) // For both subcategories and entries
  const [searchQuery, setSearchQuery] = useState("")
  const [isEditing, setIsEditing] = useState(false)
  const [editedEntry, setEditedEntry] = useState<KnowledgeEntry | null>(null)
  const [copiedCommand, setCopiedCommand] = useState<string | null>(null)
  const [showFilters, setShowFilters] = useState(false)
  const [showAddDialog, setShowAddDialog] = useState(false)
  const [showCategoryDialog, setShowCategoryDialog] = useState(false)
  const [editingCategory, setEditingCategory] = useState<Category | null>(null)
  const [newCategoryName, setNewCategoryName] = useState("")
  const [newCategoryColor, setNewCategoryColor] = useState(defaultColors[0])
  const [newCategoryParentId, setNewCategoryParentId] = useState<string | null>(null)
  const [deleteEntryDialogOpen, setDeleteEntryDialogOpen] = useState(false)
  const [deleteCategoryDialogOpen, setDeleteCategoryDialogOpen] = useState(false)
  const [categoryToDelete, setCategoryToDelete] = useState<Category | null>(null)
  const [showPhaseDialog, setShowPhaseDialog] = useState(false)
  const [editingPhase, setEditingPhase] = useState<Phase | null>(null)
  const [newPhaseName, setNewPhaseName] = useState("")
  const [newPhaseColor, setNewPhaseColor] = useState(defaultColors[0])
  const [deletePhaseDialogOpen, setDeletePhaseDialogOpen] = useState(false)
  const [phaseToDelete, setPhaseToDelete] = useState<Phase | null>(null)
  
  // Context menu state
  const [contextMenu, setContextMenu] = useState<{
    x: number
    y: number
    type: 'category' | 'entry' | 'root'
    data: Category | KnowledgeEntry | null
  } | null>(null)
  
  const [newEntry, setNewEntry] = useState<Partial<Omit<KnowledgeEntry, "id" | "createdAt" | "updatedAt">>>({
    title: "",
    domain: "",
    description: "",
    steps: [],
    commands: [],
    tags: [],
    owaspTags: [],
    notes: "",
  })
  const [activeFilters, setActiveFilters] = useState<{
    tags: string[]
    phase: string | null
    service: string | null
  }>({ tags: [], phase: null, service: null })

  // Build category tree
  const categoryTree = useMemo(() => buildCategoryTree(categories), [categories])
  
  // Helper to count entries in a category (direct only, not children)
  const countEntriesInCategory = (categoryName: string): number => {
    return entries.filter((e) => e.domain === categoryName).length
  }
  
  // Get entries for a category (with search and filter applied)
  const getEntriesInCategory = (categoryName: string): KnowledgeEntry[] => {
    return entries.filter((entry) => {
      if (entry.domain !== categoryName) return false
      
      // Apply search filter
      if (searchQuery) {
        const matchesSearch =
          entry.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
          entry.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
          entry.tags.some((tag) => tag.toLowerCase().includes(searchQuery.toLowerCase()))
        if (!matchesSearch) return false
      }
      
      // Apply tag filter
      if (activeFilters.tags.length > 0) {
        if (!activeFilters.tags.some((tag) => entry.tags.includes(tag))) return false
      }
      
      // Apply phase filter
      if (activeFilters.phase && entry.phase !== activeFilters.phase) return false
      
      // Apply service filter
      if (activeFilters.service && entry.service !== activeFilters.service) return false
      
      return true
    })
  }
  
  const toggleCategoryExpanded = (categoryId: string) => {
    setExpandedCategories((prev) => {
      const next = new Set(prev)
      if (next.has(categoryId)) {
        next.delete(categoryId)
      } else {
        next.add(categoryId)
      }
      return next
    })
  }

  // Get all unique domains from entries and categories (for legacy support)
  const allCategories = useMemo(() => {
    const entryDomains = new Set(entries.map((e) => e.domain))
    const categoryDomains = new Set(categories.map((c) => c.name))
    return Array.from(new Set([...entryDomains, ...categoryDomains])).sort()
  }, [entries, categories])
  
  // Close context menu on click outside or escape
  useEffect(() => {
    const handleClickOutside = () => setContextMenu(null)
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') setContextMenu(null)
    }
    
    if (contextMenu) {
      document.addEventListener('click', handleClickOutside)
      document.addEventListener('keydown', handleEscape)
      return () => {
        document.removeEventListener('click', handleClickOutside)
        document.removeEventListener('keydown', handleEscape)
      }
    }
  }, [contextMenu])
  
  // Reset new entry when dialog closes
  useEffect(() => {
    if (!showAddDialog) {
      setNewEntry({
        title: "",
        description: "",
        steps: [],
        commands: [],
        tags: [],
        owaspTags: [],
        notes: "",
      })
    }
  }, [showAddDialog])

  // Auto-set phase from category name if category matches a phase
  useEffect(() => {
    if (showAddDialog && selectedCategory) {
      const matchingPhase = phases.find((p) => p.name.toLowerCase() === selectedCategory.toLowerCase())
      if (matchingPhase) {
        setNewEntry((prev) => ({ ...prev, phase: matchingPhase.name }))
      }
    }
  }, [showAddDialog, selectedCategory, phases])

  // Clear selected entry if it's been deleted
  useEffect(() => {
    if (selectedEntry && !entries.find((e) => e.id === selectedEntry.id)) {
      setSelectedEntry(null)
      setIsEditing(false)
      setEditedEntry(null)
    }
  }, [entries, selectedEntry])

  const allTags = [...new Set(entries.flatMap((e) => e.tags))]
  const allPhases = [...new Set(entries.map((e) => e.phase).filter((p): p is string => Boolean(p)))]
  const allServices = [...new Set(entries.map((e) => e.service).filter((s): s is string => Boolean(s)))]

  // Expose methods via ref
  useImperativeHandle(ref, () => ({
    openAddEntryDialog: () => {
      if (!selectedCategory) {
        notification.error("No Category Selected", "Please select a category first, then use Alt+E to add an entry.")
        return
      }
      setShowAddDialog(true)
    },
    openAddCategoryDialog: () => {
      setEditingCategory(null)
      setNewCategoryName("")
      setNewCategoryColor(defaultColors[0])
      setNewCategoryParentId(null)
      setShowCategoryDialog(true)
    },
    openAddPhaseDialog: () => {
      setEditingPhase(null)
      setNewPhaseName("")
      setNewPhaseColor(defaultColors[0])
      setShowPhaseDialog(true)
    },
    getSelectedCategory: () => selectedCategory,
  }))

  const handleCopyCommand = (command: string) => {
    navigator.clipboard.writeText(command)
    setCopiedCommand(command)
    setTimeout(() => setCopiedCommand(null), 2000)
  }

  const handleStartEdit = () => {
    if (selectedEntry) {
      setEditedEntry({ ...selectedEntry })
      setIsEditing(true)
    }
  }

  const handleSaveEdit = () => {
    if (editedEntry && onUpdateEntry) {
      onUpdateEntry(editedEntry.id, editedEntry)
      setSelectedEntry(editedEntry)
    }
    setIsEditing(false)
    setEditedEntry(null)
  }

  const handleCancelEdit = () => {
    setIsEditing(false)
    setEditedEntry(null)
  }

  const handleAddEntry = async () => {
    if (!onAddEntry) return
    
    // Require a selected category
    if (!selectedCategory) {
      notification.error("No Category Selected", "Please select a category first, then click 'Add Entry' to add an entry for that category.")
      return
    }
    
    if (!newEntry.title || !newEntry.description) {
      notification.error("Validation error", "Please fill in title and description")
      return
    }

    try {
      await onAddEntry({
        title: newEntry.title,
        domain: selectedCategory, // Use selected category
        phase: newEntry.phase,
        service: newEntry.service,
        tags: newEntry.tags || [],
        owaspTags: newEntry.owaspTags || [],
        description: newEntry.description,
        steps: newEntry.steps || [],
        commands: newEntry.commands || [],
        notes: newEntry.notes || "",
      })
      setShowAddDialog(false)
      setNewEntry({
        title: "",
        description: "",
        steps: [],
        commands: [],
        tags: [],
        owaspTags: [],
        notes: "",
      })
      notification.success(`Entry added to ${selectedCategory}`)
    } catch (error) {
      console.error("Failed to add entry:", error)
      notification.error("Failed to add entry", error instanceof Error ? error.message : "An unknown error occurred")
    }
  }

  const handleDuplicate = () => {
    if (!selectedEntry || !onAddEntry) return
    
    onAddEntry({
      title: `${selectedEntry.title} (Copy)`,
      domain: selectedEntry.domain,
      phase: selectedEntry.phase,
      service: selectedEntry.service,
      tags: selectedEntry.tags,
      owaspTags: selectedEntry.owaspTags,
      description: selectedEntry.description,
      steps: selectedEntry.steps,
      commands: selectedEntry.commands,
      notes: selectedEntry.notes,
    })
  }

  const handleDelete = () => {
    if (!selectedEntry) return
    setDeleteEntryDialogOpen(true)
  }

  const handleConfirmDeleteEntry = () => {
    if (selectedEntry && onDeleteEntry) {
      onDeleteEntry(selectedEntry.id)
      setSelectedEntry(null)
      setIsEditing(false)
      setDeleteEntryDialogOpen(false)
    }
  }

  const handleCreateCategory = async () => {
    if (!newCategoryName.trim()) {
      notification.error("Validation error", "Please enter a category name")
      return
    }

    try {
      await createCategory({
        name: newCategoryName.trim(),
        color: newCategoryColor,
        parentId: newCategoryParentId,
      })
      setNewCategoryName("")
      setNewCategoryColor(defaultColors[0])
      setNewCategoryParentId(null)
      setShowCategoryDialog(false)
      notification.success("Category created")
    } catch (error: any) {
      console.error("Failed to create category:", error)
      const errorMessage = error?.message || error?.details || error?.hint || JSON.stringify(error) || "Unknown error"
      notification.error("Failed to create category", errorMessage)
    }
  }

  const handleEditCategory = (category: Category) => {
    setEditingCategory(category)
    setNewCategoryName(category.name)
    setNewCategoryColor(category.color)
    setNewCategoryParentId(category.parentId || null)
    setShowCategoryDialog(true)
  }

  const handleUpdateCategory = async () => {
    if (!editingCategory || !newCategoryName.trim()) {
      notification.error("Validation error", "Please enter a category name")
      return
    }

    // Prevent setting a category as its own parent
    if (newCategoryParentId === editingCategory.id) {
      notification.error("Validation error", "A category cannot be its own parent")
      return
    }

    try {
      await updateCategory(editingCategory.id, {
        name: newCategoryName.trim(),
        color: newCategoryColor,
        parentId: newCategoryParentId,
      })
      setEditingCategory(null)
      setNewCategoryName("")
      setNewCategoryColor(defaultColors[0])
      setNewCategoryParentId(null)
      setShowCategoryDialog(false)
      notification.success("Category updated")
    } catch (error: any) {
      console.error("Failed to update category:", error)
      const errorMessage = error?.message || error?.details || error?.hint || JSON.stringify(error) || "Unknown error"
      notification.error("Failed to update category", errorMessage)
    }
  }

  const handleDeleteCategory = (category: Category) => {
    setCategoryToDelete(category)
    setDeleteCategoryDialogOpen(true)
  }

  const handleConfirmDeleteCategory = async () => {
    if (!categoryToDelete || !onDeleteEntry) return

    try {
      // Recursively find all descendant categories
      const getAllDescendants = (categoryId: string): Category[] => {
        const directChildren = categories.filter((c) => c.parentId === categoryId)
        const allDescendants: Category[] = [...directChildren]
        
        for (const child of directChildren) {
          allDescendants.push(...getAllDescendants(child.id))
        }
        
        return allDescendants
      }
      
      // Get all descendants (children, grandchildren, etc.)
      const descendantCategories = getAllDescendants(categoryToDelete.id)
      
      // Find all entries with this category and all descendants
      const categoryNamesToDelete = [categoryToDelete.name, ...descendantCategories.map((c) => c.name)]
      const entriesToDelete = entries.filter((e) => categoryNamesToDelete.includes(e.domain))
      
      // Delete all entries first
      for (const entry of entriesToDelete) {
        try {
          await onDeleteEntry(entry.id)
        } catch (err) {
          console.error(`Failed to delete entry ${entry.id}:`, err)
          // Continue deleting other entries even if one fails
        }
      }
      
      // Then delete the category (DB will cascade delete all descendants)
      await deleteCategory(categoryToDelete.id)
      
      // Clear selection if the deleted category was selected
      if (categoryNamesToDelete.includes(selectedCategory || "")) {
        setSelectedCategory(null)
      }
      
      // Clear selected entry if it was deleted
      if (selectedEntry && entriesToDelete.some((e) => e.id === selectedEntry.id)) {
        setSelectedEntry(null)
        setIsEditing(false)
        setEditedEntry(null)
      }
      
      const entryCount = entriesToDelete.length
      const childCount = childCategories.length
      let message = "Category deleted successfully."
      if (entryCount > 0 || childCount > 0) {
        const parts: string[] = []
        if (entryCount > 0) {
          parts.push(`${entryCount} ${entryCount === 1 ? 'entry' : 'entries'}`)
        }
        if (childCount > 0) {
          parts.push(`${childCount} ${childCount === 1 ? 'subcategory' : 'subcategories'}`)
        }
        message = `Category, ${parts.join(', and ')} deleted successfully.`
      }
      notification.success("Category deleted", message)
      setCategoryToDelete(null)
      setDeleteCategoryDialogOpen(false)
    } catch (error: any) {
      console.error("Failed to delete category:", error)
      const errorMessage = error?.message || error?.details || error?.hint || JSON.stringify(error) || "Unknown error"
      notification.error("Failed to delete category", errorMessage)
    }
  }

  const handleCreatePhase = async () => {
    if (!newPhaseName.trim()) {
      notification.error("Validation error", "Please enter a phase name")
      return
    }

    try {
      await createPhase({
        name: newPhaseName.trim(),
        color: newPhaseColor,
        order: phases.length,
      })
      setNewPhaseName("")
      setNewPhaseColor(defaultColors[0])
      setShowPhaseDialog(false)
      notification.success("Phase created")
    } catch (error: any) {
      console.error("Failed to create phase:", error)
      const errorMessage = error?.message || error?.details || error?.hint || JSON.stringify(error) || "Unknown error"
      notification.error("Failed to create phase", errorMessage)
    }
  }

  const handleEditPhase = (phase: Phase) => {
    setEditingPhase(phase)
    setNewPhaseName(phase.name)
    setNewPhaseColor(phase.color)
    setShowPhaseDialog(true)
  }

  const handleUpdatePhase = async () => {
    if (!editingPhase || !newPhaseName.trim()) {
      notification.error("Validation error", "Please enter a phase name")
      return
    }

    try {
      await updatePhase(editingPhase.id, {
        name: newPhaseName.trim(),
        color: newPhaseColor,
      })
      setEditingPhase(null)
      setNewPhaseName("")
      setNewPhaseColor(defaultColors[0])
      setShowPhaseDialog(false)
      notification.success("Phase updated")
    } catch (error: any) {
      console.error("Failed to update phase:", error)
      const errorMessage = error?.message || error?.details || error?.hint || JSON.stringify(error) || "Unknown error"
      notification.error("Failed to update phase", errorMessage)
    }
  }

  const handleDeletePhase = (phase: Phase) => {
    setPhaseToDelete(phase)
    setDeletePhaseDialogOpen(true)
  }

  const handleConfirmDeletePhase = async () => {
    if (!phaseToDelete) return

    try {
      await deletePhase(phaseToDelete.id)
      notification.success("Phase deleted")
      setPhaseToDelete(null)
      setDeletePhaseDialogOpen(false)
    } catch (error: any) {
      console.error("Failed to delete phase:", error)
      const errorMessage = error?.message || error?.details || error?.hint || JSON.stringify(error) || "Unknown error"
      notification.error("Failed to delete phase", errorMessage)
    }
  }

  return (
    <div className="flex h-full flex-1 overflow-hidden">
      {/* Categories Panel */}
      <div className="flex w-72 shrink-0 flex-col border-r border-border bg-card overflow-hidden">
        <div className="flex shrink-0 flex-col border-b border-border">
          <div 
            className="flex items-center justify-between p-3"
            onContextMenu={(e) => {
              e.preventDefault()
              e.stopPropagation()
              setContextMenu({
                x: e.clientX,
                y: e.clientY,
                type: 'root',
                data: null
              })
            }}
          >
            <h2 className="text-xs font-semibold uppercase tracking-wider text-muted-foreground">
              Knowledge Categories
            </h2>
          </div>
          <div className="flex gap-1 px-2 pb-2">
            <Button 
              variant="outline" 
              size="sm" 
              className="flex-1 gap-1.5 bg-transparent text-xs h-7 min-w-0"
              onClick={() => {
                try {
                  // Strip sensitive fields (id, createdAt, updatedAt) for export
                  const exportableEntries = entries.map(stripSensitiveFields)
                  const dataStr = JSON.stringify(exportableEntries, null, 2)
                  const dataBlob = new Blob([dataStr], { type: "application/json" })
                  const url = URL.createObjectURL(dataBlob)
                  const link = document.createElement("a")
                  link.href = url
                  link.download = `knowledge-base-export-${new Date().toISOString().split("T")[0]}.json`
                  document.body.appendChild(link)
                  link.click()
                  document.body.removeChild(link)
                  URL.revokeObjectURL(url)
                  notification.success(`Exported ${entries.length} entries`)
                } catch (error) {
                  notification.error(
                    "Failed to export",
                    error instanceof Error ? error.message : "An unknown error occurred"
                  )
                }
              }}
              title="Export all knowledge base entries as JSON (importable format)"
            >
              <Download className="h-3 w-3" />
              Export All
            </Button>
            <Button 
              variant="outline" 
              size="sm" 
              className="flex-1 gap-1.5 bg-transparent text-xs h-7 min-w-0"
              onClick={() => {
                const input = document.createElement("input")
                input.type = "file"
                input.accept = "application/json"
                input.onchange = async (e) => {
                  const file = (e.target as HTMLInputElement).files?.[0]
                  if (!file) return
                  
                  try {
                    const text = await file.text()
                    const imported = JSON.parse(text)
                    
                    if (!Array.isArray(imported)) {
                      throw new Error("Invalid file format. Expected an array of entries.")
                    }
                    
                    let importedCount = 0
                    for (const entry of imported) {
                      if (onAddEntry) {
                        try {
                          await onAddEntry({
                            title: entry.title || "Imported Entry",
                            domain: entry.domain || "general",
                            phase: entry.phase,
                            service: entry.service,
                            tags: entry.tags || [],
                            owaspTags: entry.owaspTags || [],
                            description: entry.description || "",
                            steps: entry.steps || [],
                            commands: entry.commands || [],
                            notes: entry.notes || "",
                          })
                          importedCount++
                        } catch (err) {
                          console.error("Failed to import entry:", err)
                        }
                      }
                    }
                    
                    notification.success(`Imported ${importedCount} entries`)
                  } catch (error) {
                    notification.error(
                      "Failed to import",
                      error instanceof Error ? error.message : "Invalid file format"
                    )
                  }
                }
                input.click()
              }}
              title="Import entries from JSON file"
            >
              <Upload className="h-3 w-3" />
              Import
            </Button>
          </div>
        </div>
        <div 
          className="flex-1 min-h-0 relative overflow-hidden"
          onContextMenu={(e) => {
            e.preventDefault()
            setContextMenu({
              x: e.clientX,
              y: e.clientY,
              type: 'root',
              data: null
            })
          }}
        >
          <ScrollArea className="absolute inset-0">
            <div className="p-2"
          >
            <button
              type="button"
              onClick={() => setSelectedCategory(null)}
              onContextMenu={(e) => {
                e.preventDefault()
                e.stopPropagation()
                setContextMenu({
                  x: e.clientX,
                  y: e.clientY,
                  type: 'root',
                  data: null as any
                })
              }}
              className={cn(
                "mb-1 flex w-full min-w-0 items-center gap-2 rounded-md px-2 py-1.5 text-sm transition-colors",
                selectedCategory === null
                  ? "bg-primary text-primary-foreground"
                  : "text-foreground hover:bg-secondary"
              )}
            >
              <FileText className="h-4 w-4 shrink-0" />
              <span className="truncate" title="All Entries">
                All Entries
              </span>
            </button>
            {/* Category Tree View with Nested Entries */}
            {categoryTree.map((categoryNode, nodeIndex) => {
              const renderCategoryNode = (node: CategoryTreeNode, depth: number = 0, isLastSibling: boolean = false): ReactNode => {
                const isExpanded = expandedCategories.has(node.id)
                const hasSubcategories = node.children.length > 0
                const categoryEntries = getEntriesInCategory(node.name)
                const hasEntries = categoryEntries.length > 0
                const hasChildren = hasSubcategories || hasEntries
                const isSelected = selectedCategory === node.name
                
              return (
                  <div key={node.id} className="group relative">
                    <div className="flex items-center gap-1">
                      <div style={{ paddingLeft: `${depth * 1.25}rem` }} className="flex items-center gap-1 flex-1 min-w-0 relative">
                        {/* Tree line - vertical connector (stops at last sibling) */}
                        {depth > 0 && !isLastSibling && (
                          <div 
                            className="absolute left-0 top-0 bottom-0 border-l-2 border-slate-700"
                            style={{ left: `${(depth - 0.5) * 1.25}rem` }}
                          />
                        )}
                        {/* Tree line - vertical connector (half height for last sibling) */}
                        {depth > 0 && isLastSibling && (
                          <div 
                            className="absolute left-0 top-0 border-l-2 border-slate-700"
                            style={{ 
                              left: `${(depth - 0.5) * 1.25}rem`,
                              height: '50%'
                            }}
                          />
                        )}
                        {/* Tree line - horizontal connector */}
                        {depth > 0 && (
                          <div 
                            className="absolute top-1/2 border-t-2 border-slate-700"
                            style={{ 
                              left: `${(depth - 0.5) * 1.25}rem`,
                              width: '0.625rem'
                            }}
                          />
                        )}
                        {/* Single expand/collapse button for both subcategories and entries */}
                        {hasChildren ? (
                          <button
                            type="button"
                            onClick={(e) => {
                              e.stopPropagation()
                              toggleCategoryExpanded(node.id)
                            }}
                            className="h-5 w-5 flex items-center justify-center shrink-0 hover:bg-secondary rounded"
                          >
                            {isExpanded ? (
                              <ChevronDown className="h-3 w-3" />
                            ) : (
                              <ChevronRight className="h-3 w-3" />
                            )}
                          </button>
                        ) : (
                          <div className="h-5 w-5 shrink-0" />
                        )}
                        
                        {/* Category button with folder icon */}
                  <button
                    type="button"
                          onClick={() => {
                            // Double-click to view category content, single click to filter
                            if (selectedCategoryNode?.id === node.id && !selectedEntry) {
                              // Already selected, do nothing or could toggle
                            } else {
                              setSelectedCategory(node.name) // For filtering entries
                              setSelectedCategoryNode(node) // For viewing category content
                              setSelectedEntry(null) // Clear entry selection
                              setIsEditingCategory(false)
                            }
                          }}
                          onDoubleClick={() => {
                            // Double-click opens category for editing
                            setSelectedCategoryNode(node)
                            setSelectedEntry(null)
                            setIsEditing(false)
                            setIsEditingCategory(true)
                          }}
                          onContextMenu={(e) => {
                            e.preventDefault()
                            e.stopPropagation()
                            setContextMenu({
                              x: e.clientX,
                              y: e.clientY,
                              type: 'category',
                              data: node
                            })
                          }}
                    className={cn(
                            "flex flex-1 items-center justify-between gap-2 rounded-md px-2 py-1.5 text-left text-sm transition-colors min-w-0",
                            isSelected && !selectedEntry
                        ? "bg-primary text-primary-foreground"
                        : "text-foreground hover:bg-secondary"
                    )}
                  >
                    <span className="flex min-w-0 items-center gap-2">
                            {isExpanded ? (
                              <FolderOpen className="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                            ) : (
                              <Folder className="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                            )}
                      <span
                        className="max-w-[9rem] overflow-hidden text-ellipsis whitespace-nowrap"
                              title={node.name}
                      >
                              {node.name}
                      </span>
                    </span>
                          {categoryEntries.length > 0 && (
                    <Badge variant="secondary" className="h-5 shrink-0 px-1.5 text-xs">
                              {categoryEntries.length}
                    </Badge>
                          )}
                  </button>
                      </div>
                    </div>
                    
                    {/* Show entries and subcategories together when expanded */}
                    {isExpanded && (
                      <div>
                        {/* Show entries first */}
                        {hasEntries && (
                          <div style={{ paddingLeft: `${(depth + 1) * 1.25}rem` }} className="relative">
                            {/* Vertical line for entries */}
                            <div 
                              className="absolute top-0 bottom-0 border-l-2 border-slate-700"
                              style={{ left: `${depth * 1.25 + 0.125}rem` }}
                            />
                            {categoryEntries.map((entry, entryIndex) => {
                              const isEntrySelected = selectedEntry?.id === entry.id
                              const isLastEntry = entryIndex === categoryEntries.length - 1 && !hasSubcategories
                              return (
                                <div key={entry.id} className="relative">
                                  {/* Horizontal connector for entry */}
                                  <div 
                                    className="absolute top-1/2 border-t-2 border-slate-700"
                                    style={{ 
                                      left: `${depth * 1.25 + 0.125}rem`,
                                      width: '0.5rem'
                                    }}
                                  />
                                  {/* Stop vertical line at last entry if no subcategories */}
                                  {isLastEntry && (
                                    <div 
                                      className="absolute top-0 bg-card"
                                      style={{ 
                                        left: `${depth * 1.25 + 0.125}rem`,
                                        width: '2px',
                                        height: '50%'
                                      }}
                                    />
                                  )}
                                  <button
                                    type="button"
                                    onClick={() => {
                                      setSelectedEntry(entry)
                                      setSelectedCategory(node.name)
                                      setIsEditing(false)
                                      setEditedEntry(null)
                                    }}
                                    onContextMenu={(e) => {
                                      e.preventDefault()
                          e.stopPropagation()
                                      setContextMenu({
                                        x: e.clientX,
                                        y: e.clientY,
                                        type: 'entry',
                                        data: entry
                                      })
                                    }}
                                    className={cn(
                                      "flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-left text-sm transition-colors mb-0.5 relative z-10",
                                      isEntrySelected
                                        ? "bg-primary text-primary-foreground"
                                        : "text-foreground hover:bg-secondary"
                                    )}
                      >
                                    <FileText className="h-3.5 w-3.5 shrink-0" />
                                    <span className="truncate flex-1" title={entry.title}>
                                      {entry.title}
                                    </span>
                                  </button>
                </div>
              )
            })}
          </div>
                        )}
                        
                        {/* Show subcategories after entries */}
                        {hasSubcategories && (
                          <div>
                            {node.children.map((child, childIndex) => 
                              renderCategoryNode(child, depth + 1, childIndex === node.children.length - 1)
                            )}
          </div>
              )}
          </div>
                    )}
                </div>
                )
              }
              
              return renderCategoryNode(categoryNode, 0, nodeIndex === categoryTree.length - 1)
            })}
            
            {/* Show categories that exist in entries but not in category tree (legacy entries) */}
            {allCategories
              .filter((name) => !categories.some((c) => c.name === name))
              .map((categoryName) => {
                const count = entries.filter((e) => e.domain === categoryName).length
                const legacyEntries = getEntriesInCategory(categoryName)
                const hasEntries = legacyEntries.length > 0
                const isExpanded = expandedCategories.has(`legacy-${categoryName}`)
                const isSelected = selectedCategory === categoryName
                
                return (
                  <div key={categoryName} className="group">
                    <div className="flex items-center gap-1">
                      <div className="flex items-center gap-1 flex-1 min-w-0">
                        {/* Expand/collapse for legacy category entries */}
                        {hasEntries ? (
                          <button
                            type="button"
                            onClick={(e) => {
                              e.stopPropagation()
                              setExpandedCategories((prev) => {
                                const next = new Set(prev)
                                const key = `legacy-${categoryName}`
                                if (next.has(key)) {
                                  next.delete(key)
                                } else {
                                  next.add(key)
                                }
                                return next
                              })
                            }}
                            className="h-5 w-5 flex items-center justify-center shrink-0 hover:bg-secondary rounded"
                          >
                            {isExpanded ? (
                              <ChevronDown className="h-3 w-3" />
                            ) : (
                              <ChevronRight className="h-3 w-3" />
                            )}
                          </button>
                        ) : (
                          <div className="h-5 w-5 shrink-0" />
                        )}
                        
                <button
                  type="button"
                          onClick={() => setSelectedCategory(categoryName)}
                          onContextMenu={(e) => {
                            e.preventDefault()
                            e.stopPropagation()
                            // Create a temporary category object for legacy categories
                            const tempCategory: Category = {
                              id: `legacy-${categoryName}`,
                              name: categoryName,
                              color: defaultColors[0],
                              parentId: null,
                              createdAt: new Date().toISOString(),
                              updatedAt: new Date().toISOString()
                            }
                            setContextMenu({
                              x: e.clientX,
                              y: e.clientY,
                              type: 'category',
                              data: tempCategory
                            })
                  }}
                  className={cn(
                            "flex w-full items-center justify-between gap-2 rounded-md px-2 py-1.5 text-left text-sm transition-colors",
                            isSelected && !selectedEntry
                      ? "bg-primary text-primary-foreground"
                              : "text-foreground hover:bg-secondary"
                  )}
                >
                          <span className="flex min-w-0 items-center gap-2">
                            {isExpanded ? (
                              <FolderOpen className="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                            ) : (
                              <Folder className="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                            )}
                            <span
                              className="max-w-[9rem] overflow-hidden text-ellipsis whitespace-nowrap"
                              title={categoryName}
                            >
                              {categoryName}
                            </span>
                          </span>
                          {count > 0 && (
                            <Badge variant="secondary" className="h-5 shrink-0 px-1.5 text-xs">
                              {count}
                    </Badge>
                          )}
                        </button>
                      </div>
                    </div>
                    
                    {/* Show entries if expanded */}
                    {hasEntries && isExpanded && (
                      <div style={{ paddingLeft: `1.25rem` }} className="relative">
                        {/* Vertical line for entries */}
                        <div 
                          className="absolute top-0 bottom-0 border-l-2 border-slate-700"
                          style={{ left: '0.125rem' }}
                        />
                        {legacyEntries.map((entry, entryIndex) => {
                          const isEntrySelected = selectedEntry?.id === entry.id
                          const isLastEntry = entryIndex === legacyEntries.length - 1
                          return (
                            <div key={entry.id} className="relative">
                              {/* Horizontal connector for entry */}
                              <div 
                                className="absolute top-1/2 border-t-2 border-slate-700"
                                style={{ 
                                  left: '0.125rem',
                                  width: '0.5rem'
                                }}
                              />
                              {/* Stop vertical line at last entry */}
                              {isLastEntry && (
                                <div 
                                  className="absolute top-0 bg-card"
                                  style={{ 
                                    left: '0.125rem',
                                    width: '2px',
                                    height: '50%'
                                  }}
                                />
                              )}
                              <button
                                type="button"
                                onClick={() => {
                                  setSelectedEntry(entry)
                                  setSelectedCategory(categoryName)
                                  setIsEditing(false)
                                  setEditedEntry(null)
                                }}
                                onContextMenu={(e) => {
                                  e.preventDefault()
                                  e.stopPropagation()
                                  setContextMenu({
                                    x: e.clientX,
                                    y: e.clientY,
                                    type: 'entry',
                                    data: entry
                                  })
                                }}
                        className={cn(
                                  "flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-left text-sm transition-colors mb-0.5 relative z-10",
                                  isEntrySelected
                                    ? "bg-primary text-primary-foreground"
                                    : "text-foreground hover:bg-secondary"
                        )}
                      >
                                <FileText className="h-3.5 w-3.5 shrink-0" />
                                <span className="truncate flex-1" title={entry.title}>
                                  {entry.title}
                                </span>
                </button>
                            </div>
                          )
                        })}
                      </div>
            )}
                  </div>
                )
              })}
          </div>
          </ScrollArea>
        </div>
        <div className="shrink-0 border-t border-border p-2">
          <div className="flex items-center justify-center py-2 text-xs text-muted-foreground">
            Right-click to add categories & entries
          </div>
        </div>
      </div>

      {/* Entry/Category View Panel */}
      <div className="flex flex-1 flex-col overflow-hidden bg-background">
        {selectedCategoryNode && !selectedEntry ? (
          /* Category Content View */
          <>
            <div className="flex items-center justify-between border-b border-border px-4 py-3">
              <div className="flex items-center gap-3">
                <Folder className="h-5 w-5 text-muted-foreground" />
                <h2 className="text-lg font-semibold">
                  {selectedCategoryNode.name}
                </h2>
                <Badge className="text-xs">Category</Badge>
              </div>
              <div className="flex items-center gap-2">
                {isEditingCategory ? (
                  <>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="gap-1.5"
                      onClick={() => setIsEditingCategory(false)}
                    >
                      <X className="h-4 w-4" />
                      Cancel
                    </Button>
                    <Button 
                      size="sm" 
                      className="gap-1.5" 
                      onClick={async () => {
                        try {
                          await updateCategory(selectedCategoryNode.id, selectedCategoryNode)
                          setIsEditingCategory(false)
                          notification.success("Category updated")
                        } catch (error) {
                          notification.error("Failed to update category", error instanceof Error ? error.message : "Unknown error")
                        }
                      }}
                    >
                      <Check className="h-4 w-4" />
                      Save
                    </Button>
                  </>
                ) : (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="gap-1.5"
                    onClick={() => setIsEditingCategory(true)}
                  >
                    <Pencil className="h-4 w-4" />
                    Edit Content
                  </Button>
                )}
              </div>
            </div>
            <ScrollArea className="flex-1">
              <div className="max-w-3xl p-6 space-y-6">
                <div className="space-y-2">
                  <label className="text-sm font-medium">Description</label>
                  {isEditingCategory ? (
                    <Textarea
                      value={selectedCategoryNode.description || ""}
                      onChange={(e) => setSelectedCategoryNode({...selectedCategoryNode, description: e.target.value})}
                      placeholder="Category description..."
                      className="min-h-[100px]"
                    />
                  ) : (
                    <p className="text-sm text-muted-foreground whitespace-pre-wrap">
                      {selectedCategoryNode.description || "No description"}
                    </p>
                  )}
                </div>
                
                <div className="space-y-2">
                  <label className="text-sm font-medium">Notes</label>
                  {isEditingCategory ? (
                    <Textarea
                      value={selectedCategoryNode.notes || ""}
                      onChange={(e) => setSelectedCategoryNode({...selectedCategoryNode, notes: e.target.value})}
                      placeholder="Additional notes..."
                      className="min-h-[150px]"
                    />
                  ) : (
                    <p className="text-sm text-muted-foreground whitespace-pre-wrap">
                      {selectedCategoryNode.notes || "No notes"}
                    </p>
                  )}
                </div>
              </div>
            </ScrollArea>
          </>
        ) : selectedEntry ? (
          <>
            <div className="flex items-center justify-between border-b border-border px-4 py-3">
              <div className="flex items-center gap-3">
                <h2 className="text-lg font-semibold">
                  {isEditing ? (
                    <Input
                      value={editedEntry?.title || ""}
                      onChange={(e) =>
                        setEditedEntry((prev) =>
                          prev ? { ...prev, title: e.target.value } : null
                        )
                      }
                      className="h-8 w-64 bg-input"
                    />
                  ) : (
                    selectedEntry.title
                  )}
                </h2>
                {!isEditing && (
                  <Badge className="text-xs">Read-only</Badge>
                )}
              </div>
              <div className="flex items-center gap-2">
                {isEditing ? (
                  <>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="gap-1.5"
                      onClick={handleCancelEdit}
                    >
                      <X className="h-4 w-4" />
                      Cancel
                    </Button>
                    <Button size="sm" className="gap-1.5" onClick={handleSaveEdit}>
                      <Check className="h-4 w-4" />
                      Save
                    </Button>
                  </>
                ) : (
                  <>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="gap-1.5"
                      onClick={handleStartEdit}
                    >
                      <Pencil className="h-4 w-4" />
                      Edit
                    </Button>
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className="gap-1.5"
                      onClick={handleDuplicate}
                    >
                      <Files className="h-4 w-4" />
                      Duplicate
                    </Button>
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className="gap-1.5"
                      onClick={() => {
                        notification.info(
                          "Coming soon",
                          "Link to Rule functionality coming soon. This will allow you to create a rule based on this knowledge entry."
                        )
                      }}
                    >
                      <Link2 className="h-4 w-4" />
                      Link to Rule
                    </Button>
                    {onDeleteEntry && (
                      <Button 
                        variant="ghost" 
                        size="sm" 
                        className="gap-1.5 text-destructive hover:text-destructive"
                        onClick={handleDelete}
                      >
                        <Trash2 className="h-4 w-4" />
                        Delete
                      </Button>
                    )}
                  </>
                )}
              </div>
            </div>
            <ScrollArea className="flex-1">
              <div className="max-w-3xl p-6 space-y-6">
                {/* Meta Info */}
                <div className="flex flex-wrap items-center gap-2">
                  {isEditing ? (
                    <Select
                      value={editedEntry?.domain || ""}
                      onValueChange={(value) =>
                        setEditedEntry((prev) =>
                          prev ? { ...prev, domain: value } : null
                        )
                      }
                    >
                      <SelectTrigger className="w-48 bg-input">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        {allCategories.map((categoryName) => (
                          <SelectItem key={categoryName} value={categoryName}>
                            {categoryName}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <Badge className={getCategoryColor(selectedEntry.domain, categories)}>
                      {selectedEntry.domain}
                    </Badge>
                  )}
                  {isEditing ? (
                    <>
                      <Select
                        value={editedEntry?.phase || "none"}
                        onValueChange={(value) =>
                          setEditedEntry((prev) =>
                            prev ? { 
                              ...prev, 
                              phase: value === "none" ? undefined : value
                            } : null
                          )
                        }
                      >
                        <SelectTrigger className="w-40 bg-input">
                          <SelectValue placeholder="Phase" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="none">None</SelectItem>
                          {phases.map((phase) => (
                            <SelectItem key={phase.id} value={phase.name}>
                              {phase.name}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <Input
                        value={editedEntry?.service || ""}
                        onChange={(e) =>
                          setEditedEntry((prev) =>
                            prev ? { ...prev, service: e.target.value || undefined } : null
                          )
                        }
                        placeholder="Service"
                        className="w-32 bg-input"
                      />
                    </>
                  ) : (
                    <>
                      {selectedEntry.phase && (
                        <Badge 
                          variant="outline"
                          className={getPhaseColor(selectedEntry.phase, phases)}
                        >
                          {selectedEntry.phase}
                        </Badge>
                      )}
                      {selectedEntry.service && (
                        <Badge variant="outline">{selectedEntry.service}</Badge>
                      )}
                    </>
                  )}
                  {selectedEntry.owaspTags.map((tag) => (
                    <Badge key={tag} variant="secondary">
                      {tag}
                    </Badge>
                  ))}
                  {selectedEntry.tags.map((tag) => (
                    <Badge key={tag} variant="outline" className="text-muted-foreground">
                      {tag}
                    </Badge>
                  ))}
                </div>

                {/* Description */}
                <div>
                  <h3 className="mb-2 text-sm font-semibold uppercase tracking-wider text-muted-foreground">
                    Description
                  </h3>
                  {isEditing ? (
                    <Textarea
                      value={editedEntry?.description || ""}
                      onChange={(e) =>
                        setEditedEntry((prev) =>
                          prev ? { ...prev, description: e.target.value } : null
                        )
                      }
                      className="min-h-24 bg-input font-sans"
                    />
                  ) : (
                    <p className="leading-relaxed text-foreground/90">
                      {selectedEntry.description}
                    </p>
                  )}
                </div>

                {/* Steps */}
                <div>
                  <div className="mb-2 flex items-center justify-between">
                    <h3 className="text-sm font-semibold uppercase tracking-wider text-muted-foreground">
                      Steps
                    </h3>
                    {isEditing && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        className="h-7 gap-1.5 text-xs"
                        onClick={() => {
                          setEditedEntry((prev) =>
                            prev ? { ...prev, steps: [...(prev.steps || []), ""] } : null
                          )
                        }}
                      >
                        <Plus className="h-3 w-3" />
                        Add Step
                      </Button>
                    )}
                  </div>
                  {isEditing ? (
                    <div className="space-y-2">
                      {(editedEntry?.steps || []).map((step, idx) => (
                        <div key={idx} className="flex items-start gap-2">
                          <div className="flex h-9 w-9 shrink-0 items-center justify-center rounded-md border border-border bg-muted text-sm font-medium">
                            {idx + 1}
                          </div>
                          <Input
                            value={step}
                            onChange={(e) => {
                              const newSteps = [...(editedEntry?.steps || [])]
                              newSteps[idx] = e.target.value
                              setEditedEntry((prev) => prev ? { ...prev, steps: newSteps } : null)
                            }}
                            placeholder={`Step ${idx + 1} description...`}
                            className="bg-input"
                          />
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            className="h-9 w-9 shrink-0 text-destructive hover:text-destructive"
                            onClick={() => {
                              const newSteps = (editedEntry?.steps || []).filter((_, i) => i !== idx)
                              setEditedEntry((prev) => prev ? { ...prev, steps: newSteps } : null)
                            }}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      ))}
                      {(!editedEntry?.steps || editedEntry.steps.length === 0) && (
                        <p className="text-sm text-muted-foreground py-2">No steps defined. Click "Add Step" to add one.</p>
                      )}
                    </div>
                  ) : selectedEntry.steps.length > 0 ? (
                    <ol className="list-inside list-decimal space-y-2">
                      {selectedEntry.steps.map((step, idx) => (
                        <li key={idx} className="leading-relaxed text-foreground/90">
                          {step}
                        </li>
                      ))}
                    </ol>
                  ) : (
                    <p className="text-sm text-muted-foreground">No steps defined</p>
                  )}
                </div>

                {/* Commands */}
                <div>
                  <div className="mb-2 flex items-center justify-between">
                    <h3 className="text-sm font-semibold uppercase tracking-wider text-muted-foreground">
                      Commands
                    </h3>
                    {isEditing && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        className="h-7 gap-1.5 text-xs"
                        onClick={() => {
                          setEditedEntry((prev) =>
                            prev ? { ...prev, commands: [...(prev.commands || []), { command: "", description: "" }] } : null
                          )
                        }}
                      >
                        <Plus className="h-3 w-3" />
                        Add Command
                      </Button>
                    )}
                  </div>
                  {isEditing ? (
                    <div className="space-y-3">
                      {(editedEntry?.commands || []).map((cmd, idx) => (
                        <div key={idx} className="rounded-lg border border-border bg-card p-3 space-y-2">
                          <div className="flex items-center justify-between">
                            <Label className="text-xs text-muted-foreground">Command {idx + 1}</Label>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              className="h-6 w-6 text-destructive hover:text-destructive"
                              onClick={() => {
                                const newCommands = (editedEntry?.commands || []).filter((_, i) => i !== idx)
                                setEditedEntry((prev) => prev ? { ...prev, commands: newCommands } : null)
                              }}
                            >
                              <Trash2 className="h-3 w-3" />
                            </Button>
                          </div>
                          <Input
                            value={cmd.command}
                            onChange={(e) => {
                              const newCommands = [...(editedEntry?.commands || [])]
                              newCommands[idx] = { ...newCommands[idx], command: e.target.value }
                              setEditedEntry((prev) => prev ? { ...prev, commands: newCommands } : null)
                            }}
                            placeholder="e.g., nmap -sV -p 22 <target>"
                            className="bg-input font-mono text-sm"
                          />
                          <Input
                            value={cmd.description}
                            onChange={(e) => {
                              const newCommands = [...(editedEntry?.commands || [])]
                              newCommands[idx] = { ...newCommands[idx], description: e.target.value }
                              setEditedEntry((prev) => prev ? { ...prev, commands: newCommands } : null)
                            }}
                            placeholder="Description of what this command does (optional)"
                            className="bg-input text-sm"
                          />
                        </div>
                      ))}
                      {(!editedEntry?.commands || editedEntry.commands.length === 0) && (
                        <p className="text-sm text-muted-foreground py-2">No commands defined. Click "Add Command" to add one.</p>
                      )}
                    </div>
                  ) : selectedEntry.commands.length > 0 ? (
                    <div className="space-y-3">
                      {selectedEntry.commands.map((cmd, idx) => (
                        <div
                          key={idx}
                          className="rounded-lg border border-border bg-card"
                        >
                          {cmd.description && (
                            <div className="border-b border-border px-3 py-2 text-sm text-muted-foreground">
                              {cmd.description}
                            </div>
                          )}
                          <div className="flex items-center justify-between gap-2 p-3">
                            <code className="font-mono text-sm text-foreground">
                              {cmd.command}
                            </code>
                            <Button
                              variant="ghost"
                              size="icon"
                              className="h-8 w-8 shrink-0"
                              onClick={() => handleCopyCommand(cmd.command)}
                            >
                              {copiedCommand === cmd.command ? (
                                <Check className="h-4 w-4 text-success" />
                              ) : (
                                <Copy className="h-4 w-4" />
                              )}
                            </Button>
                          </div>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <p className="text-sm text-muted-foreground">No commands defined</p>
                  )}
                </div>

                {/* Notes */}
                {selectedEntry.notes && (
                  <div>
                    <h3 className="mb-2 text-sm font-semibold uppercase tracking-wider text-muted-foreground">
                      Notes
                    </h3>
                    {isEditing ? (
                      <Textarea
                        value={editedEntry?.notes || ""}
                        onChange={(e) =>
                          setEditedEntry((prev) =>
                            prev ? { ...prev, notes: e.target.value } : null
                          )
                        }
                        className="min-h-24 bg-input font-sans"
                      />
                    ) : (
                      <div className="rounded-lg border border-warning/30 bg-warning/10 p-4">
                        <p className="text-sm leading-relaxed text-warning">
                          {selectedEntry.notes}
                        </p>
                      </div>
                    )}
                  </div>
                )}

                {/* Metadata */}
                <div className="border-t border-border pt-4 text-xs text-muted-foreground">
                  <p>Created: {new Date(selectedEntry.createdAt).toLocaleDateString()}</p>
                  <p>Updated: {new Date(selectedEntry.updatedAt).toLocaleDateString()}</p>
                </div>
              </div>
            </ScrollArea>
          </>
        ) : (
          <div className="flex flex-1 items-center justify-center">
            <div className="text-center">
              <FileText className="mx-auto mb-3 h-12 w-12 text-muted-foreground/30" />
              <p className="text-muted-foreground">Select an entry to view</p>
            </div>
          </div>
        )}
      </div>

      {/* Add Entry Dialog */}
      <Dialog open={showAddDialog} onOpenChange={setShowAddDialog}>
        <DialogContent className="max-w-3xl max-h-[90vh] bg-card">
          <DialogHeader>
            <DialogTitle>Add Knowledge Entry to {selectedCategory}</DialogTitle>
            <DialogDescription>
              Create a new knowledge base entry in the {selectedCategory} category.
            </DialogDescription>
          </DialogHeader>
          <ScrollArea className="max-h-[calc(90vh-150px)] pr-4">
            <div className="space-y-4 py-4">
              {/* Category (read-only) */}
              <div className="space-y-2">
                <Label>Category</Label>
                <div className="flex items-center gap-2">
                  <Badge className={getCategoryColor(selectedCategory || "", categories)}>
                    {selectedCategory}
                  </Badge>
                  <span className="text-xs text-muted-foreground">(Selected category)</span>
                </div>
              </div>

              {/* Title */}
              <div className="space-y-2">
                <Label htmlFor="title">Title *</Label>
                <Input
                  id="title"
                  value={newEntry.title || ""}
                  onChange={(e) => setNewEntry({ ...newEntry, title: e.target.value })}
                  placeholder="e.g., SSH Enumeration"
                  className="bg-input"
                />
              </div>

              {/* Phase and Service */}
              {(() => {
                const matchingPhase = selectedCategory 
                  ? phases.find((p) => p.name.toLowerCase() === selectedCategory.toLowerCase())
                  : undefined
                const showPhaseSelector = !matchingPhase
                
                return (
                  <div className={showPhaseSelector ? "grid grid-cols-2 gap-4" : "space-y-4"}>
                    {showPhaseSelector && (
                <div className="space-y-2">
                  <Label htmlFor="phase">Phase (optional)</Label>
                  <Select
                    value={newEntry.phase || "none"}
                    onValueChange={(value) => setNewEntry({ 
                      ...newEntry, 
                            phase: value === "none" ? undefined : value
                    })}
                  >
                    <SelectTrigger className="bg-input">
                      <SelectValue placeholder="Select phase (optional)" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">None</SelectItem>
                            {phases.map((phase) => (
                              <SelectItem key={phase.id} value={phase.name}>
                                {phase.name}
                              </SelectItem>
                            ))}
                    </SelectContent>
                  </Select>
                </div>
                    )}
                    {matchingPhase && (
                <div className="space-y-2">
                        <Label>Phase</Label>
                        <div className="flex items-center gap-2">
                          <Badge 
                            variant="outline" 
                            className={cn("text-sm", getPhaseColor(matchingPhase.name, phases))}
                          >
                            {matchingPhase.name}
                          </Badge>
                          <span className="text-xs text-muted-foreground">
                            (auto-set from category)
                          </span>
                        </div>
                      </div>
                    )}
                    <div className={showPhaseSelector ? "space-y-2" : "space-y-2"}>
                  <Label htmlFor="service">Service (optional)</Label>
                  <Input
                    id="service"
                    value={newEntry.service || ""}
                    onChange={(e) => setNewEntry({ ...newEntry, service: e.target.value || undefined })}
                    placeholder="e.g., ssh, http"
                    className="bg-input"
                  />
                </div>
              </div>
                )
              })()}

              {/* Description */}
              <div className="space-y-2">
                <Label htmlFor="description">Description *</Label>
                <Textarea
                  id="description"
                  value={newEntry.description || ""}
                  onChange={(e) => setNewEntry({ ...newEntry, description: e.target.value })}
                  placeholder="Describe the technique or tool..."
                  className="min-h-24 bg-input"
                />
              </div>

              {/* Steps - Improved Management */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label>Steps</Label>
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    className="h-7 gap-1.5 text-xs"
                    onClick={() => {
                      setNewEntry({
                        ...newEntry,
                        steps: [...(newEntry.steps || []), ""]
                      })
                    }}
                  >
                    <Plus className="h-3 w-3" />
                    Add Step
                  </Button>
                </div>
                <div className="space-y-2">
                  {(newEntry.steps || []).map((step, idx) => (
                    <div key={idx} className="flex items-start gap-2">
                      <div className="flex h-9 w-9 shrink-0 items-center justify-center rounded-md border border-border bg-muted text-sm font-medium">
                        {idx + 1}
                      </div>
                      <Input
                        value={step}
                        onChange={(e) => {
                          const newSteps = [...(newEntry.steps || [])]
                          newSteps[idx] = e.target.value
                          setNewEntry({ ...newEntry, steps: newSteps })
                        }}
                        placeholder={`Step ${idx + 1} description...`}
                        className="bg-input"
                      />
                      <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        className="h-9 w-9 shrink-0 text-destructive hover:text-destructive"
                        onClick={() => {
                          const newSteps = (newEntry.steps || []).filter((_, i) => i !== idx)
                          setNewEntry({ ...newEntry, steps: newSteps })
                        }}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  ))}
                  {(!newEntry.steps || newEntry.steps.length === 0) && (
                    <p className="text-sm text-muted-foreground py-2">No steps added yet. Click "Add Step" to add one.</p>
                  )}
                </div>
              </div>

              {/* Commands - Improved Management */}
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label>Commands</Label>
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    className="h-7 gap-1.5 text-xs"
                    onClick={() => {
                      setNewEntry({
                        ...newEntry,
                        commands: [...(newEntry.commands || []), { command: "", description: "" }]
                      })
                    }}
                  >
                    <Plus className="h-3 w-3" />
                    Add Command
                  </Button>
                </div>
                <div className="space-y-3">
                  {(newEntry.commands || []).map((cmd, idx) => (
                    <div key={idx} className="rounded-lg border border-border bg-card p-3 space-y-2">
                      <div className="flex items-center justify-between">
                        <Label className="text-xs text-muted-foreground">Command {idx + 1}</Label>
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          className="h-6 w-6 text-destructive hover:text-destructive"
                          onClick={() => {
                            const newCommands = (newEntry.commands || []).filter((_, i) => i !== idx)
                            setNewEntry({ ...newEntry, commands: newCommands })
                          }}
                        >
                          <Trash2 className="h-3 w-3" />
                        </Button>
                      </div>
                      <Input
                        value={cmd.command}
                        onChange={(e) => {
                          const newCommands = [...(newEntry.commands || [])]
                          newCommands[idx] = { ...newCommands[idx], command: e.target.value }
                          setNewEntry({ ...newEntry, commands: newCommands })
                        }}
                        placeholder="e.g., nmap -sV -p 22 <target>"
                        className="bg-input font-mono text-sm"
                      />
                      <Input
                        value={cmd.description}
                        onChange={(e) => {
                          const newCommands = [...(newEntry.commands || [])]
                          newCommands[idx] = { ...newCommands[idx], description: e.target.value }
                          setNewEntry({ ...newEntry, commands: newCommands })
                        }}
                        placeholder="Description of what this command does (optional)"
                        className="bg-input text-sm"
                      />
                    </div>
                  ))}
                  {(!newEntry.commands || newEntry.commands.length === 0) && (
                    <p className="text-sm text-muted-foreground py-2">No commands added yet. Click "Add Command" to add one.</p>
                  )}
                </div>
              </div>

              {/* Notes */}
              <div className="space-y-2">
                <Label htmlFor="notes">Notes (optional)</Label>
                <Textarea
                  id="notes"
                  value={newEntry.notes || ""}
                  onChange={(e) => setNewEntry({ ...newEntry, notes: e.target.value })}
                  placeholder="Additional notes or warnings..."
                  className="min-h-20 bg-input"
                />
              </div>
            </div>
          </ScrollArea>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowAddDialog(false)}>
              Cancel
            </Button>
            <Button onClick={handleAddEntry}>
              Add Entry
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Category Dialog */}
      <Dialog open={showCategoryDialog} onOpenChange={setShowCategoryDialog}>
        <DialogContent className="max-w-md bg-card">
          <DialogHeader>
            <DialogTitle>{editingCategory ? "Edit Category" : "Create Category"}</DialogTitle>
            <DialogDescription>
              {editingCategory ? "Update the category name and description." : "Create a new category to organize your knowledge base entries."}
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="category-name">Category Name *</Label>
              <Input
                id="category-name"
                value={newCategoryName}
                onChange={(e) => setNewCategoryName(e.target.value)}
                placeholder="e.g., Enumeration, Exploitation"
                className="bg-input"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="category-parent">Parent Category (optional)</Label>
              <Select
                value={newCategoryParentId || "none"}
                onValueChange={(value) => setNewCategoryParentId(value === "none" ? null : value)}
              >
                <SelectTrigger className="bg-input">
                  <SelectValue placeholder="Select parent category" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="none">None (Root Level)</SelectItem>
                  {categories
                    .filter((cat) => !editingCategory || cat.id !== editingCategory.id)
                    .map((cat) => (
                      <SelectItem key={cat.id} value={cat.id}>
                        {cat.name}
                      </SelectItem>
                    ))}
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground">
                Select a parent category to create a nested hierarchy (like folders)
              </p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="category-color">Color</Label>
              <div className="grid grid-cols-5 gap-2">
                {defaultColors.map((color) => (
                  <button
                    key={color}
                    type="button"
                    onClick={() => setNewCategoryColor(color)}
                    className={cn(
                      "h-10 w-full rounded-md border-2 transition-all",
                      newCategoryColor === color
                        ? "border-primary ring-2 ring-primary ring-offset-2"
                        : "border-border hover:border-primary/50"
                    )}
                  >
                    <div className={cn("h-full w-full rounded", color)} />
                  </button>
                ))}
              </div>
              <Input
                value={newCategoryColor}
                onChange={(e) => setNewCategoryColor(e.target.value)}
                placeholder="Or enter custom Tailwind classes"
                className="bg-input mt-2"
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => {
              setShowCategoryDialog(false)
              setEditingCategory(null)
              setNewCategoryName("")
              setNewCategoryColor(defaultColors[0])
              setNewCategoryParentId(null)
            }}>
              Cancel
            </Button>
            <Button onClick={editingCategory ? handleUpdateCategory : handleCreateCategory}>
              {editingCategory ? "Update" : "Create"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Entry Confirmation Dialog */}
      <AlertDialog open={deleteEntryDialogOpen} onOpenChange={setDeleteEntryDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete "{selectedEntry?.title}"?</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this knowledge entry? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleConfirmDeleteEntry}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Delete Category Confirmation Dialog */}
      <AlertDialog open={deleteCategoryDialogOpen} onOpenChange={setDeleteCategoryDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete category "{categoryToDelete?.name}"?</AlertDialogTitle>
            <AlertDialogDescription>
              {(() => {
                if (!categoryToDelete) return "This action cannot be undone."
                
                // Recursively find all descendant categories
                const getAllDescendants = (categoryId: string): Category[] => {
                  const directChildren = categories.filter((c) => c.parentId === categoryId)
                  const allDescendants: Category[] = [...directChildren]
                  
                  for (const child of directChildren) {
                    allDescendants.push(...getAllDescendants(child.id))
                  }
                  
                  return allDescendants
                }
                
                const descendantCategories = getAllDescendants(categoryToDelete.id)
                const categoryNamesToDelete = [categoryToDelete.name, ...descendantCategories.map((c) => c.name)]
                const entryCount = entries.filter((e) => categoryNamesToDelete.includes(e.domain)).length
                
                const parts: string[] = []
                if (entryCount > 0) {
                  parts.push(`${entryCount} ${entryCount === 1 ? 'entry' : 'entries'}`)
                }
                if (descendantCategories.length > 0) {
                  parts.push(`${descendantCategories.length} ${descendantCategories.length === 1 ? 'subcategory' : 'subcategories'}`)
                }
                
                if (parts.length > 0) {
                  return `This will delete the category and all ${parts.join(' and ')} associated with it. This action cannot be undone.`
                }
                return "This will delete the category. This action cannot be undone."
              })()}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleConfirmDeleteCategory}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Phase Dialog */}
      <Dialog open={showPhaseDialog} onOpenChange={setShowPhaseDialog}>
        <DialogContent className="max-w-md bg-card">
          <DialogHeader>
            <DialogTitle>{editingPhase ? "Edit Phase" : "Create Phase"}</DialogTitle>
            <DialogDescription>
              {editingPhase ? "Update the phase name and color." : "Create a new phase for your methodology."}
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="phase-name">Phase Name *</Label>
              <Input
                id="phase-name"
                value={newPhaseName}
                onChange={(e) => setNewPhaseName(e.target.value)}
                placeholder="e.g., Reconnaissance, Enumeration"
                className="bg-input"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="phase-color">Color</Label>
              <div className="grid grid-cols-5 gap-2">
                {defaultColors.map((color) => (
                  <button
                    key={color}
                    type="button"
                    onClick={() => setNewPhaseColor(color)}
                    className={cn(
                      "h-10 w-full rounded-md border-2 transition-all",
                      newPhaseColor === color
                        ? "border-primary ring-2 ring-primary ring-offset-2"
                        : "border-border hover:border-primary/50"
                    )}
                  >
                    <div className={cn("h-full w-full rounded", color)} />
                  </button>
                ))}
              </div>
              <Input
                value={newPhaseColor}
                onChange={(e) => setNewPhaseColor(e.target.value)}
                placeholder="Or enter custom Tailwind classes"
                className="bg-input mt-2"
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => {
              setShowPhaseDialog(false)
              setEditingPhase(null)
              setNewPhaseName("")
              setNewPhaseColor(defaultColors[0])
            }}>
              Cancel
            </Button>
            <Button onClick={editingPhase ? handleUpdatePhase : handleCreatePhase}>
              {editingPhase ? "Update" : "Create"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Phase Confirmation Dialog */}
      <AlertDialog open={deletePhaseDialogOpen} onOpenChange={setDeletePhaseDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete phase "{phaseToDelete?.name}"?</AlertDialogTitle>
            <AlertDialogDescription>
              Entries and rules using this phase will keep the phase name but the phase definition will be removed. This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleConfirmDeletePhase}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Context Menu */}
      {contextMenu && (
        <div
          className="fixed z-50 min-w-[180px] rounded-md border border-border bg-popover shadow-lg"
          style={{
            left: `${contextMenu.x}px`,
            top: `${contextMenu.y}px`,
          }}
          onClick={(e) => e.stopPropagation()}
        >
          <div className="p-1">
            {contextMenu.type === 'root' && (
              <>
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    setSelectedCategory(null)
                    setNewCategoryParentId(null)
                    setEditingCategory(null)
                    setNewCategoryName("")
                    setNewCategoryColor(defaultColors[0])
                    setShowCategoryDialog(true)
                    setContextMenu(null)
                  }}
                >
                  <Folder className="h-4 w-4" />
                  Add Category
                </button>
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    setSelectedCategory(null)
                    setShowAddDialog(true)
                    setContextMenu(null)
                  }}
                >
                  <FileText className="h-4 w-4" />
                  Add Entry
                </button>
                <div className="my-1 h-px bg-border" />
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    setEditingPhase(null)
                    setNewPhaseName("")
                    setNewPhaseColor(defaultColors[0])
                    setShowPhaseDialog(true)
                    setContextMenu(null)
                  }}
                >
                  <Plus className="h-4 w-4" />
                  Add Phase
                </button>
              </>
            )}
            {contextMenu.type === 'category' && (
              <>
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    const category = contextMenu.data as Category
                    setSelectedCategory(category.name)
                    setNewCategoryParentId(category.id)
                    setEditingCategory(null)
                    setNewCategoryName("")
                    setNewCategoryColor(defaultColors[0])
                    setShowCategoryDialog(true)
                    setContextMenu(null)
                  }}
                >
                  <Plus className="h-4 w-4" />
                  Add Subcategory
                </button>
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    const category = contextMenu.data as Category
                    setSelectedCategory(category.name)
                    setShowAddDialog(true)
                    setContextMenu(null)
                  }}
                >
                  <FileText className="h-4 w-4" />
                  Add Entry
                </button>
                <div className="my-1 h-px bg-border" />
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    const category = contextMenu.data as Category
                    handleEditCategory(category)
                    setContextMenu(null)
                  }}
                >
                  <Edit className="h-4 w-4" />
                  Edit
                </button>
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm text-destructive hover:bg-destructive/10 outline-none"
                  onClick={() => {
                    const category = contextMenu.data as Category
                    handleDeleteCategory(category)
                    setContextMenu(null)
                  }}
                >
                  <Trash2 className="h-4 w-4" />
                  Delete
                </button>
              </>
            )}
            {contextMenu.type === 'entry' && (
              <>
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    const entry = contextMenu.data as KnowledgeEntry
                    setSelectedEntry(entry)
                    setIsEditing(true)
                    setEditedEntry({ ...entry })
                    setContextMenu(null)
                  }}
                >
                  <Edit className="h-4 w-4" />
                  Edit
                </button>
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm hover:bg-accent hover:text-accent-foreground outline-none"
                  onClick={() => {
                    const entry = contextMenu.data as KnowledgeEntry
                    const newEntry = {
                      ...entry,
                      title: `${entry.title} (Copy)`,
                      id: "",
                    }
                    delete (newEntry as any).createdAt
                    delete (newEntry as any).updatedAt
                    onAddEntry(newEntry)
                    setContextMenu(null)
                  }}
                >
                  <Copy className="h-4 w-4" />
                  Duplicate
                </button>
                <div className="my-1 h-px bg-border" />
                <button
                  className="flex w-full items-center gap-2 rounded-sm px-2 py-1.5 text-sm text-destructive hover:bg-destructive/10 outline-none"
                  onClick={() => {
                    const entry = contextMenu.data as KnowledgeEntry
                    setSelectedEntry(entry)
                    setDeleteEntryDialogOpen(true)
                    setContextMenu(null)
                  }}
                >
                  <Trash2 className="h-4 w-4" />
                  Delete
                </button>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  )
})

KnowledgeBase.displayName = "KnowledgeBase"
