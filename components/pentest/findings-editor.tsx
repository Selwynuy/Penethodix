"use client"

import { useState, useCallback, useEffect } from "react"
import { FileText, PlusCircle, Trash2, Save, AlertTriangle, XCircle, ChevronLeft, ChevronRight } from "lucide-react"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Textarea } from "@/components/ui/textarea"
import { ResizablePanelGroup, ResizablePanel, ResizableHandle } from "@/components/ui/resizable"
import { ScrollArea } from "@/components/ui/scroll-area"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog"
import { notification } from "@/components/ui/notification"
import { cn } from "@/lib/utils"
import { Finding, FindingSeverity, FindingStatus, Target, Engagement } from "@/lib/types"

interface FindingsEditorProps {
  findings: Finding[]
  activeEngagement: Engagement
  targets: Target[]
  selectedTarget: Target | null
  onUpdateFinding: (id: string, updates: Partial<Finding>) => Promise<Finding>
  onDeleteFinding: (id: string) => Promise<void>
  onCreateFinding: (finding: Omit<Finding, "id" | "created_at" | "updated_at">) => Promise<Finding>
}

export function FindingsEditor({
  findings,
  activeEngagement,
  targets,
  selectedTarget,
  onUpdateFinding,
  onDeleteFinding,
  onCreateFinding,
}: FindingsEditorProps) {
  const [selectedFindingId, setSelectedFindingId] = useState<string | null>(null)
  const [editingFinding, setEditingFinding] = useState<Finding | null>(null)
  const [isConfirmingDelete, setIsConfirmingDelete] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [showFindingsList, setShowFindingsList] = useState(true);

  // Effect to set selected finding when findings or selection changes
  useEffect(() => {
    if (selectedFindingId) {
      const current = findings.find((f) => f.id === selectedFindingId)
      setEditingFinding(current || null)
    } else if (findings.length > 0) { // Auto-select first finding if none is selected
      setSelectedFindingId(findings[0].id);
      setEditingFinding(findings[0]);
    } else {
      setEditingFinding(null);
    }
  }, [selectedFindingId, findings])

  const handleSelectFinding = useCallback((id: string) => {
    if (editingFinding && hasUnsavedChanges(editingFinding, findings.find(f => f.id === editingFinding.id))) {
      if (!window.confirm("You have unsaved changes. Discard them?")) {
        return;
      }
    }
    setSelectedFindingId(id)
  }, [editingFinding, findings])

  const handleEditChange = useCallback((field: keyof Finding, value: any) => {
    setEditingFinding((prev) => (prev ? { ...prev, [field]: value } : null))
  }, [])

  const hasUnsavedChanges = (current: Finding | null, original: Finding | undefined) => {
    if (!current || !original) return false;
    return (
      current.title !== original.title ||
      current.severity !== original.severity ||
      current.status !== original.status ||
      current.description !== original.description ||
      current.target_id !== original.target_id
    );
  };

  const handleSaveEdits = useCallback(async () => {
    if (!editingFinding || !selectedFindingId) return
    setIsSaving(true)
    try {
      // Find the original finding to compare for changes
      const originalFinding = findings.find(f => f.id === selectedFindingId);

      if (hasUnsavedChanges(editingFinding, originalFinding)) {
        await onUpdateFinding(selectedFindingId, {
          title: editingFinding.title,
          severity: editingFinding.severity,
          status: editingFinding.status,
          description: editingFinding.description,
          target_id: editingFinding.target_id,
        })
        notification.success("Finding saved")
      } else {
        notification.info("No changes to save.")
      }
    } catch (error) {
      console.error("Failed to save finding:", error)
      notification.error("Failed to save finding", error instanceof Error ? error.message : "An unknown error occurred")
    } finally {
      setIsSaving(false)
    }
  }, [editingFinding, selectedFindingId, onUpdateFinding, findings])

  const [isCreatingFinding, setIsCreatingFinding] = useState(false)

  const handleCreateNewFinding = useCallback(async () => {
    // Validate: Must have a selected target
    if (!selectedTarget) {
      notification.error(
        "No Target Selected",
        "Please select a target first, then click 'New Finding' to add a finding for that target."
      )
      return
    }

    // Prevent double-clicks
    if (isCreatingFinding) {
      return
    }

    try {
      setIsCreatingFinding(true)

      const newFinding = await onCreateFinding({
        engagement_id: activeEngagement.id,
        title: "New Finding",
        severity: "medium",
        status: "open",
        description: "",
        target_id: selectedTarget.id, // Use selected target
      })
      setSelectedFindingId(newFinding.id)
      notification.success(`New finding created for ${selectedTarget.ip}`)
    } catch (error) {
      console.error("Failed to create new finding:", error)
      const errorMessage = error instanceof Error ? error.message : "An unknown error occurred"
      
      // Handle duplicate key error - this indicates a database constraint issue
      if (errorMessage.includes("duplicate key") || errorMessage.includes("unique constraint")) {
        if (errorMessage.includes("engagement_id")) {
          notification.error(
            "Database Constraint Error",
            "Your database has a UNIQUE constraint on engagement_id preventing multiple findings. Run 'fix_findings_unique_constraint.sql' in Supabase SQL Editor to fix this."
          )
        } else {
          notification.error(
            "Database Constraint Error",
            "A database constraint is preventing creation. Each finding has a unique UUID ID, so this shouldn't happen. Please check your database schema."
          )
        }
      } else {
        notification.error("Failed to create finding", errorMessage)
      }
    } finally {
      setIsCreatingFinding(false)
    }
  }, [onCreateFinding, activeEngagement, selectedTarget, isCreatingFinding])

  const handleDeleteFinding = useCallback(async () => {
    if (!selectedFindingId) return
    setIsConfirmingDelete(false)
    try {
      await onDeleteFinding(selectedFindingId)
      setSelectedFindingId(null)
      notification.success("Finding deleted")
    } catch (error) {
      console.error("Failed to delete finding:", error)
      notification.error("Failed to delete finding", error instanceof Error ? error.message : "An unknown error occurred")
    }
  }, [selectedFindingId, onDeleteFinding])

  return (
    <div className="flex h-full flex-col bg-background">
      <div className="flex h-10 shrink-0 items-center justify-between border-b border-border px-4">
        <div className="flex items-center gap-3">
          <FileText className="mr-1.5 h-3 w-3 text-muted-foreground" />
          <span className="text-sm font-medium">Findings</span>
        </div>
        <div className="flex items-center gap-3">
          <Button
            variant="ghost"
            size="sm"
            className="h-7 px-2 text-xs"
            onClick={handleCreateNewFinding}
            disabled={!activeEngagement.id || !selectedTarget || isCreatingFinding}
            title={!selectedTarget ? "Select a target first, then click to add a finding for that target" : `Create new finding for ${selectedTarget.ip}`}
          >
            <PlusCircle className="mr-1.5 h-3 w-3" />
            {isCreatingFinding ? "Creating..." : "New Finding"}
          </Button>
          <Button
            variant="ghost"
            size="sm"
            className="h-7 px-2 text-xs"
            onClick={handleSaveEdits}
            disabled={!editingFinding || isSaving || !hasUnsavedChanges(editingFinding, findings.find(f => f.id === editingFinding.id))}
          >
            <Save className="mr-1.5 h-3 w-3" />
            {isSaving ? "Saving..." : "Save Edits"}
          </Button>
          <AlertDialog open={isConfirmingDelete} onOpenChange={setIsConfirmingDelete}>
            <AlertDialogTrigger asChild>
              <Button
                variant="ghost"
                size="sm"
                className="h-7 px-2 text-xs text-destructive hover:text-destructive"
                disabled={!selectedFindingId}
              >
                <Trash2 className="mr-1.5 h-3 w-3" />
                Delete
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                <AlertDialogDescription>
                  This action cannot be undone. This will permanently delete the selected finding.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction onClick={handleDeleteFinding} className="bg-destructive hover:bg-destructive-hover">
                  Delete
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </div>
      </div>

      <ResizablePanelGroup direction="horizontal">
        {showFindingsList && (
          <>
            <ResizablePanel defaultSize={25} minSize={15} maxSize={40} className="min-w-[200px]">
              <div className="flex items-center justify-between p-2 border-b">
                <h3 className="text-sm font-semibold">All Findings ({findings.length})</h3>
                <Button variant="ghost" size="icon" onClick={() => setShowFindingsList(false)}>
                  <ChevronLeft className="h-4 w-4" />
                </Button>
              </div>
              <ScrollArea className="h-[calc(100%-40px)]">
                {findings.length === 0 ? (
                  <p className="p-4 text-muted-foreground text-sm">No findings yet. Click "New Finding" to add one.</p>
                ) : (
                  findings.map((finding) => (
                    <div
                      key={finding.id}
                      className={cn(
                        "flex flex-col gap-1 p-3 border-b cursor-pointer hover:bg-muted/50",
                        selectedFindingId === finding.id && "bg-muted"
                      )}
                      onClick={() => handleSelectFinding(finding.id)}
                    >
                      <h4 className="text-sm font-medium truncate">{finding.title || "Untitled Finding"}</h4>
                      <div className="flex items-center gap-2 text-xs">
                        <Badge variant="secondary" className={cn(
                          "px-2 py-0.5",
                          finding.severity === "critical" && "bg-red-500/20 text-red-500",
                          finding.severity === "high" && "bg-orange-500/20 text-orange-500",
                          finding.severity === "medium" && "bg-yellow-500/20 text-yellow-500",
                          finding.severity === "low" && "bg-blue-500/20 text-blue-500",
                          finding.severity === "informational" && "bg-gray-500/20 text-gray-500"
                        )}>
                          {finding.severity}
                        </Badge>
                        <Badge variant="outline" className={cn(
                          "px-2 py-0.5",
                          finding.status === "open" && "text-blue-400",
                          finding.status === "in_progress" && "text-yellow-400",
                          finding.status === "retesting" && "text-purple-400",
                          finding.status === "closed" && "text-green-400"
                        )}>
                          {finding.status.replace(/_/g, ' ')}
                        </Badge>
                      </div>
                    </div>
                  ))
                )}
              </ScrollArea>
            </ResizablePanel>
            <ResizableHandle withHandle />
          </>
        )}
        <ResizablePanel defaultSize={75}>
          <div className="flex h-full flex-col">
            <div className="flex items-center p-2 border-b">
              {!showFindingsList && (
                <Button variant="ghost" size="icon" onClick={() => setShowFindingsList(true)} className="mr-2">
                  <ChevronRight className="h-4 w-4" />
                </Button>
              )}
              <h3 className="text-sm font-semibold">Finding Details</h3>
            </div>
            {!editingFinding ? (
              <div className="flex flex-1 items-center justify-center text-muted-foreground text-sm">
                Select a finding or create a new one.
              </div>
            ) : (
              <ScrollArea className="flex-1 p-4">
                <div className="grid gap-4">
                  <div className="grid gap-2">
                    <Label htmlFor="finding-title">Title</Label>
                    <Input
                      id="finding-title"
                      value={editingFinding.title}
                      onChange={(e) => handleEditChange("title", e.target.value)}
                    />
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div className="grid gap-2">
                      <Label htmlFor="finding-severity">Severity</Label>
                      <Select
                        value={editingFinding.severity}
                        onValueChange={(value: FindingSeverity) => handleEditChange("severity", value)}
                      >
                        <SelectTrigger id="finding-severity">
                          <SelectValue placeholder="Select Severity" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="critical">Critical</SelectItem>
                          <SelectItem value="high">High</SelectItem>
                          <SelectItem value="medium">Medium</SelectItem>
                          <SelectItem value="low">Low</SelectItem>
                          <SelectItem value="informational">Informational</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>

                    <div className="grid gap-2">
                      <Label htmlFor="finding-status">Status</Label>
                      <Select
                        value={editingFinding.status}
                        onValueChange={(value: FindingStatus) => handleEditChange("status", value)}
                      >
                        <SelectTrigger id="finding-status">
                          <SelectValue placeholder="Select Status" />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="open">Open</SelectItem>
                          <SelectItem value="in_progress">In Progress</SelectItem>
                          <SelectItem value="retesting">Retesting</SelectItem>
                          <SelectItem value="closed">Closed</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  </div>

                  <div className="grid gap-2">
                    <Label htmlFor="finding-target">Associated Target</Label>
                    <Select
                      value={editingFinding.target_id || "none"}
                      onValueChange={(value) => handleEditChange("target_id", value === "none" ? null : value)}
                    >
                      <SelectTrigger id="finding-target">
                        <SelectValue placeholder="Select Target" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="none">Unassigned</SelectItem>
                        {targets.map((target) => (
                          <SelectItem key={target.id} value={target.id}>
                            {target.label || target.ip}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="grid gap-2">
                    <Label htmlFor="finding-description">Description</Label>
                    <Textarea
                      id="finding-description"
                      value={editingFinding.description || ""}
                      onChange={(e) => handleEditChange("description", e.target.value)}
                      rows={10}
                    />
                  </div>
                </div>
              </ScrollArea>
            )}
          </div>
        </ResizablePanel>
      </ResizablePanelGroup>
    </div>
  )
}
